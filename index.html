<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rich Text Comparison Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .input-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
            
        }

        .input-group {
            display: flex;
            flex-direction: column;
            overflow-y: scroll;
            overflow-x: scroll;
        }

        .input-group label {
            font-weight: 600;
            margin-bottom: 10px;
            color: #2c3e50;
            font-size: 1.1em;
        }

        .text-input {
            min-height: 300px;
            max-height: 400px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            font-size: 14px;
            line-height: 1.6;
            overflow-y: auto;
            resize: none;
            outline: none;
            transition: all 0.3s ease;
            background: white;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.05);
            min-width: 100%;
            max-width: 100%;
        }

        .text-input:focus {
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        .text-input[contenteditable="true"] {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Ensure input and output fields use the same font family */
        #text1, #text2, #originalResult, #modifiedResult {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif !important;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
            box-shadow: 0 4px 15px rgba(149, 165, 166, 0.4);
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(149, 165, 166, 0.6);
        }

        .result-section {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
        }

        .result-section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Fix width and enable horizontal scroll for right panel */
        .comparison-panel:last-child {
            width: 500px;
            min-width: 500px;
            max-width: 500px;
            overflow-x: auto;
            display: block;
        }
        .comparison-panel:last-child .comparison-content {
            width: 100%;
            min-width: 500px;
            max-width: 500px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-word;
            display: block;
        }

        .comparison-panel {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
        }

        .comparison-header {
            background: #f8f9fa;
            padding: 10px 15px;
            font-weight: 600;
            color: #2c3e50;
            border-bottom: 1px solid #e0e0e0;
        }

        .comparison-content {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.6;
            font-size: 14px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e0e0e0;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
        }

        .diff-added {
            background-color: #d4edda !important;
            color: #155724 !important;
            padding: 2px 4px;
            border-radius: 3px;
            text-decoration: none;
        }

        .diff-removed {
            background-color: #f8d7da !important;
            color: #721c24 !important;
            padding: 2px 4px;
            border-radius: 3px;
            text-decoration: line-through;
        }

        .diff-modified {
            background-color: #fff3cd !important;
            color: #856404 !important;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .formatting-changes {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .formatting-changes h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .formatting-change {
            background: white;
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 6px;
            border-left: 4px solid #f39c12;
            font-size: 13px;
        }

        .no-differences {
            text-align: center;
            color: #28a745;
            font-size: 18px;
            padding: 40px;
            background: #d4edda;
            border-radius: 8px;
            border: 1px solid #c3e6cb;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .toolbar button {
            padding: 6px 12px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .toolbar button:hover {
            background: #e9ecef;
        }

        .toolbar button.active {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }

        @media (max-width: 768px) {
            .input-section {
                grid-template-columns: 1fr;
            }
            
            .comparison-grid {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Text Comparison</h1>
            <p>Compare text with formatting detection - Bold, Italic, Tables & More!</p>
        </div>

        <div class="main-content">
            <div class="input-section">
                <div class="input-group">
                    <label for="text1">Original Text:</label>
                    <div class="toolbar">
                        <button onclick="formatText('bold', 'text1')">B</button>
                        <button onclick="formatText('italic', 'text1')">I</button>
                        <button onclick="formatText('underline', 'text1')">U</button>
                        <button onclick="insertTable('text1')">Table</button>
                        <button onclick="clearFormatting('text1')">Clear</button>
                        <input type="text" id="findTextInput" placeholder="Find text to delete..." style="margin-left:10px; padding:4px; font-size:12px; width:140px;">
                        <button onclick="findAndDeleteInOriginal()" style="background:#e74c3c; color:white;">Delete All</button>
                    </div>
                    <div id="text1" class="text-input" contenteditable="true" placeholder="Paste or type your original text here. You can use Ctrl+V to paste rich content with formatting..."></div>
                </div>

                <div class="input-group">
                    <label for="text2">Modified Text:</label>
                    <div class="toolbar">
                        <button onclick="formatText('bold', 'text2')">B</button>
                        <button onclick="formatText('italic', 'text2')">I</button>
                        <button onclick="formatText('underline', 'text2')">U</button>
                        <button onclick="insertTable('text2')">Table</button>
                        <button onclick="clearFormatting('text2')">Clear</button>
                    </div>
                    <div id="text2" class="text-input" contenteditable="true" placeholder="Paste or type your modified text here. You can use Ctrl+V to paste rich content with formatting..."></div>
                </div>
            </div>

            <div class="controls">
                <button class="btn btn-primary" onclick="compareTexts()">Compare Texts</button>
                <button class="btn btn-secondary" onclick="clearAll()">Clear All</button>
            </div>

            <div id="results" class="result-section" style="display: none;">
                <h2>Comparison Results</h2>
                
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="totalChanges">0</div>
                        <div class="stat-label">Total Changes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="textChanges">0</div>
                        <div class="stat-label">Text Changes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="formatChanges">0</div>
                        <div class="stat-label">Format Changes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="similarity">100%</div>
                        <div class="stat-label">Similarity</div>
                    </div>
                </div>

                <div class="comparison-grid">
                    <div class="comparison-panel">
                        <div class="comparison-header">Original Text</div>
                        <div class="comparison-content" id="originalResult"></div>
                    </div>
                    <div class="comparison-panel">
                        <div class="comparison-header">Modified Text</div>
                        <div class="comparison-content" id="modifiedResult"></div>
                    </div>
                </div>

                <div class="formatting-changes" id="formattingChanges">
                    <h3>Formatting Changes Detected:</h3>
                    <div id="formattingList"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Find and delete all occurrences of a string in the original text (bulk delete)
        function findAndDeleteInOriginal() {
            const findValue = document.getElementById('findTextInput').value;
            const text1Div = document.getElementById('text1');
            if (!findValue) {
                alert('Please enter text to find and delete.');
                return;
            }
            // Normalize function: trims, collapses whitespace, decodes HTML entities
            function normalize(str) {
                const txt = document.createElement('textarea');
                txt.innerHTML = str;
                let value = txt.value;
                // Remove zero-width, non-breaking, and other invisible unicode spaces
                value = value.replace(/[\u200B-\u200D\uFEFF\u00A0]/g, '');
                // Replace multiple whitespace (including tabs, newlines) with a single space
                value = value.replace(/\s+/g, ' ');
                // Optionally, remove spaces before/after punctuation (uncomment if needed)
                // value = value.replace(/\s*([.,!?;:])\s*/g, '$1 ');
                return value.trim().toLowerCase();
            }
            // Build a flat string of all visible text, mapping each character to its text node and offset
            const walker = document.createTreeWalker(text1Div, NodeFilter.SHOW_TEXT, null, false);
            let node;
            let fullText = '';
            const nodeMap = []; // {node, start, end, localStart, localEnd}
            let pos = 0;
            while ((node = walker.nextNode())) {
                const text = node.textContent;
                if (text.length > 0) {
                    nodeMap.push({ node, start: pos, end: pos + text.length, localStart: 0, localEnd: text.length });
                    fullText += text;
                    pos += text.length;
                }
            }
            // Normalize both fullText and search string
            const normFullText = normalize(fullText);
            const normFind = normalize(findValue);
            // Find all matches (global, overlapping)
            let matchIndexes = [];
            let idx = 0;
            while ((idx = normFullText.indexOf(normFind, idx)) !== -1) {
                matchIndexes.push(idx);
                idx += normFind.length > 0 ? 1 : 0;
                if (normFind.length === 0) break; // avoid infinite loop
            }
            if (matchIndexes.length === 0) {
                // Fallback: if the normalized text contains the search string, but mapping failed, do a best-effort delete
                if (normFullText.includes(normFind) && normFind.length > 0) {
                    // Try to delete the first occurrence in the original text
                    let firstIdx = fullText.toLowerCase().indexOf(findValue.toLowerCase());
                    if (firstIdx !== -1) {
                        // Find which node this is in
                        let nIdx = nodeMap.findIndex(n => n.start <= firstIdx && n.end > firstIdx);
                        if (nIdx !== -1) {
                            let n = nodeMap[nIdx];
                            let relStart = firstIdx - n.start;
                            let relEnd = relStart + findValue.length;
                            n.node.textContent = n.node.textContent.slice(0, relStart) + n.node.textContent.slice(relEnd);
                            // Remove empty tags (td, th, tr, p, div, span)
                            const tags = ['td', 'th', 'tr', 'p', 'div', 'span'];
                            tags.forEach(tag => {
                                const elements = text1Div.querySelectorAll(tag);
                                elements.forEach(el => {
                                    if (!el.textContent.trim() && el.childElementCount === 0) {
                                        el.remove();
                                    }
                                });
                            });
                            return;
                        }
                    }
                }
                alert('No matches found to delete.');
                return;
            }
            // For each match, remove the corresponding characters from the text nodes
            // We need to map normalized positions back to original text positions
            // To do this, walk both the original and normalized fullText in parallel
            function buildNormMap(str) {
                // Map: normPos -> origPos
                let map = [];
                let orig = 0, norm = 0;
                while (orig < str.length) {
                    if (/\s/.test(str[orig])) {
                        // collapse whitespace to single space in normalized
                        let ws = '';
                        while (orig < str.length && /\s/.test(str[orig])) { ws += str[orig]; orig++; }
                        map.push({ normPos: norm, origPos: orig - ws.length });
                        norm++;
                    } else {
                        map.push({ normPos: norm, origPos: orig });
                        orig++;
                        norm++;
                    }
                }
                return map;
            }
            const normMap = buildNormMap(fullText.toLowerCase());
            // For each match, get the original start/end positions
            let toDelete = [];
            matchIndexes.forEach(normStart => {
                // Find origStart and origEnd in normMap
                let origStart = normMap.find(m => m.normPos === normStart)?.origPos;
                let origEnd = normMap.find(m => m.normPos === normStart + normFind.length - 1)?.origPos;
                if (origStart === undefined || origEnd === undefined) return;
                toDelete.push({ origStart, origEnd: origEnd + 1 });
            });
            // Merge overlapping/adjacent ranges
            toDelete.sort((a, b) => a.origStart - b.origStart);
            let merged = [];
            toDelete.forEach(r => {
                if (!merged.length || merged[merged.length - 1].origEnd < r.origStart) {
                    merged.push(r);
                } else {
                    merged[merged.length - 1].origEnd = Math.max(merged[merged.length - 1].origEnd, r.origEnd);
                }
            });
            // Remove text in reverse order to not mess up positions
            for (let i = merged.length - 1; i >= 0; i--) {
                const { origStart, origEnd } = merged[i];
                // Find which nodes this range covers
                let startIdx = nodeMap.findIndex(n => n.start <= origStart && n.end > origStart);
                let endIdx = nodeMap.findIndex(n => n.start < origEnd && n.end >= origEnd);
                if (startIdx === -1 || endIdx === -1) continue;
                if (startIdx === endIdx) {
                    // All in one node
                    let n = nodeMap[startIdx];
                    let relStart = origStart - n.start;
                    let relEnd = origEnd - n.start;
                    n.node.textContent = n.node.textContent.slice(0, relStart) + n.node.textContent.slice(relEnd);
                } else {
                    // Spans multiple nodes
                    // First node: remove from relStart to end
                    let n1 = nodeMap[startIdx];
                    let relStart = origStart - n1.start;
                    n1.node.textContent = n1.node.textContent.slice(0, relStart);
                    // Middle nodes: clear
                    for (let j = startIdx + 1; j < endIdx; j++) {
                        nodeMap[j].node.textContent = '';
                    }
                    // Last node: remove from 0 to relEnd
                    let n2 = nodeMap[endIdx];
                    let relEnd = origEnd - n2.start;
                    n2.node.textContent = n2.node.textContent.slice(relEnd);
                }
            }
            // Remove empty tags (td, th, tr, p, div, span)
            const tags = ['td', 'th', 'tr', 'p', 'div', 'span'];
            tags.forEach(tag => {
                const elements = text1Div.querySelectorAll(tag);
                elements.forEach(el => {
                    if (!el.textContent.trim() && el.childElementCount === 0) {
                        el.remove();
                    }
                });
            });
        }
        // <script> tag removed for JS file context
        let comparisonData = {
            textChanges: 0,
            formatChanges: 0,
            totalChanges: 0,
            formattingDifferences: []
        };

        function formatText(command, textId) {
            const element = document.getElementById(textId);
            element.focus();
            document.execCommand(command, false, null);
        }

        function insertTable(textId) {
            const element = document.getElementById(textId);
            const tableHTML = `
                <table border="1" style="border-collapse: collapse; margin: 10px 0;">
                    <tr>
                        <th style="padding: 8px; background: #f0f0f0;">Header 1</th>
                        <th style="padding: 8px; background: #f0f0f0;">Header 2</th>
                    </tr>
                    <tr>
                        <td style="padding: 8px;">Cell 1</td>
                        <td style="padding: 8px;">Cell 2</td>
                    </tr>
                </table>
            `;
            element.focus();
            document.execCommand('insertHTML', false, tableHTML);
        }

        function clearFormatting(textId) {
            const element = document.getElementById(textId);
            element.focus();
            document.execCommand('removeFormat', false, null);
        }

        function clearAll() {
            document.getElementById('text1').innerHTML = '';
            document.getElementById('text2').innerHTML = '';
            document.getElementById('results').style.display = 'none';
            comparisonData = {
                textChanges: 0,
                formatChanges: 0,
                totalChanges: 0,
                formattingDifferences: []
            };
        }

        function extractTextAndFormatting(element) {
            const html = element.innerHTML;
            const text = element.innerText;
            
            // Extract formatting information
            const formatting = [];
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_ALL,
                null,
                false
            );

            let node;
            let position = 0;
            
            while (node = walker.nextNode()) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const parent = node.parentNode;
                    const textContent = node.textContent;
                    
                    if (parent && parent !== element) {
                        const styles = window.getComputedStyle(parent);
                        const tagName = parent.tagName.toLowerCase();
                        
                        formatting.push({
                            start: position,
                            end: position + textContent.length,
                            text: textContent,
                            tag: tagName,
                            bold: styles.fontWeight === 'bold' || styles.fontWeight >= 600 || tagName === 'b' || tagName === 'strong',
                            italic: styles.fontStyle === 'italic' || tagName === 'i' || tagName === 'em',
                            underline: styles.textDecoration.includes('underline') || tagName === 'u',
                            color: styles.color,
                            fontSize: styles.fontSize,
                            fontFamily: styles.fontFamily
                        });
                    }
                    
                    position += textContent.length;
                }
            }

            return {
                text: text,
                html: html,
                formatting: formatting
            };
        }

        // Helper to get formatting for a word at a given position
        function getFormattingForWord(formatArr, word, pos) {
            for (let i = 0; i < formatArr.length; i++) {
                const f = formatArr[i];
                if (f.start <= pos && pos < f.end && f.text.includes(word)) {
                    return f;
                }
            }
            return null;
        }

        function compareFormattingForUnchangedWords(words1, words2, format1, format2, textDiff) {
            const differences = [];
            let pos1 = 0, pos2 = 0;
            let widx1 = 0, widx2 = 0;
            textDiff.forEach(part => {
                if (part.type === 'unchanged') {
                    const word1 = words1[widx1] || '';
                    const word2 = words2[widx2] || '';
                    const f1 = getFormattingForWord(format1, word1, pos1);
                    const f2 = getFormattingForWord(format2, word2, pos2);
                    if (f1 && f2) {
                        if (f1.bold !== f2.bold) {
                            differences.push(`Bold formatting changed: ${f1.bold ? 'removed' : 'added'} at word '${word1}'`);
                        }
                        if (f1.italic !== f2.italic) {
                            differences.push(`Italic formatting changed: ${f1.italic ? 'removed' : 'added'} at word '${word1}'`);
                        }
                        if (f1.underline !== f2.underline) {
                            differences.push(`Underline formatting changed: ${f1.underline ? 'removed' : 'added'} at word '${word1}'`);
                        }
                    } else if ((f1 && !f2) || (!f1 && f2)) {
                        if ((f1 && f1.bold) || (f2 && f2.bold)) {
                            differences.push(`Bold formatting changed at word '${word1}'`);
                        }
                        if ((f1 && f1.italic) || (f2 && f2.italic)) {
                            differences.push(`Italic formatting changed at word '${word1}'`);
                        }
                        if ((f1 && f1.underline) || (f2 && f2.underline)) {
                            differences.push(`Underline formatting changed at word '${word1}'`);
                        }
                    }
                    pos1 += word1.length + 1;
                    pos2 += word2.length + 1;
                    widx1++;
                    widx2++;
                } else if (part.type === 'removed') {
                    const word1 = words1[widx1] || '';
                    pos1 += word1.length + 1;
                    widx1++;
                } else if (part.type === 'added') {
                    const word2 = words2[widx2] || '';
                    pos2 += word2.length + 1;
                    widx2++;
                }
            });
            return differences;
        }

        function compareTexts() {
            const text1Element = document.getElementById('text1');
            const text2Element = document.getElementById('text2');
            const data1 = extractTextAndFormatting(text1Element);
            const data2 = extractTextAndFormatting(text2Element);
            // Simple word-based comparison that actually works
            const textDiff = simpleWordDiff(data1.text, data2.text);
            // Compare formatting only for unchanged words
            const words1 = data1.text.trim().split(/\s+/);
            const words2 = data2.text.trim().split(/\s+/);
            const formatDiff = compareFormattingForUnchangedWords(words1, words2, data1.formatting, data2.formatting, textDiff);
            // Compare HTML for table and structure changes
            const htmlDiff = data1.html !== data2.html;
            // Display results
            displayResults(data1, data2, textDiff, formatDiff, htmlDiff);
        }

        function simpleWordDiff(text1, text2) {
            // Split into words
            const words1 = text1.trim().split(/\s+/);
            const words2 = text2.trim().split(/\s+/);
            
            // Create a simple diff by comparing word by word
            const diff = [];
            const maxLength = Math.max(words1.length, words2.length);
            
            for (let i = 0; i < maxLength; i++) {
                const word1 = words1[i] || '';
                const word2 = words2[i] || '';
                
                if (word1 === word2) {
                    if (word1) diff.push({ type: 'unchanged', value: word1 });
                } else {
                    if (word1) diff.push({ type: 'removed', value: word1 });
                    if (word2) diff.push({ type: 'added', value: word2 });
                }
            }
            
            return diff;
        }

        function displayResults(data1, data2, textDiff, formatDiff, htmlDiff) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.style.display = 'block';
            
            // Count changes
            const textChanges = textDiff.filter(d => d.type !== 'unchanged').length;
            const formatChanges = formatDiff.length;
            const totalChanges = textChanges + formatChanges + (htmlDiff ? 1 : 0);
            
            // Calculate similarity
            const totalWords = Math.max(data1.text.split(/\s+/).filter(w => w.length > 0).length, 
                                      data2.text.split(/\s+/).filter(w => w.length > 0).length);
            const unchangedWords = textDiff.filter(d => d.type === 'unchanged').length;
            const similarity = totalWords > 0 ? Math.round((unchangedWords / totalWords) * 100) : 100;
            
            // Update stats
            document.getElementById('totalChanges').textContent = totalChanges;
            document.getElementById('textChanges').textContent = textChanges;
            document.getElementById('formatChanges').textContent = formatChanges;
            document.getElementById('similarity').textContent = similarity + '%';
            

            // Helper to check formatting for a word at a given position
            function getFormattingForWord(formatArr, word, pos) {
                // Find formatting that covers this word's position
                for (let i = 0; i < formatArr.length; i++) {
                    const f = formatArr[i];
                    if (f.start <= pos && pos < f.end && f.text.includes(word)) {
                        return f;
                    }
                }
                return null;
            }

            // Build highlighted HTML for original and modified text, including formatting changes
            let originalHTML = '';
            let modifiedHTML = '';
            let pos1 = 0, pos2 = 0;
            let widx1 = 0, widx2 = 0;
            const words1 = data1.text.trim().split(/\s+/);
            const words2 = data2.text.trim().split(/\s+/);

            textDiff.forEach(part => {
                if (part.type === 'unchanged') {
                    // Check for formatting differences
                    const word1 = words1[widx1] || '';
                    const word2 = words2[widx2] || '';
                    const f1 = getFormattingForWord(data1.formatting, word1, pos1);
                    const f2 = getFormattingForWord(data2.formatting, word2, pos2);
                    let hasFormatDiff = false;
                    if (f1 && f2) {
                        if (f1.bold !== f2.bold || f1.italic !== f2.italic || f1.underline !== f2.underline) {
                            hasFormatDiff = true;
                        }
                    } else if ((f1 && !f2) || (!f1 && f2)) {
                        hasFormatDiff = true;
                    }
                    if (hasFormatDiff) {
                        // Highlight as modified in both panels
                        originalHTML += `<span class="diff-modified">${word1}</span> `;
                        modifiedHTML += `<span class="diff-modified">${word2}</span> `;
                    } else {
                        originalHTML += `${word1} `;
                        modifiedHTML += `${word2} `;
                    }
                    pos1 += word1.length + 1;
                    pos2 += word2.length + 1;
                    widx1++;
                    widx2++;
                } else if (part.type === 'removed') {
                    const word1 = words1[widx1] || '';
                    originalHTML += `<span class="diff-removed">${word1}</span> `;
                    pos1 += word1.length + 1;
                    widx1++;
                } else if (part.type === 'added') {
                    const word2 = words2[widx2] || '';
                    modifiedHTML += `<span class="diff-added">${word2}</span> `;
                    pos2 += word2.length + 1;
                    widx2++;
                }
            });

            // Display results
            const originalResult = document.getElementById('originalResult');
            const modifiedResult = document.getElementById('modifiedResult');
            originalResult.innerHTML = originalHTML.trim();
            modifiedResult.innerHTML = modifiedHTML.trim();
            
            // Display formatting changes
            const formattingList = document.getElementById('formattingList');
            formattingList.innerHTML = '';
            
            if (formatDiff.length > 0) {
                formatDiff.forEach(change => {
                    const changeDiv = document.createElement('div');
                    changeDiv.className = 'formatting-change';
                    changeDiv.textContent = change;
                    formattingList.appendChild(changeDiv);
                });
            } else if (htmlDiff) {
                const changeDiv = document.createElement('div');
                changeDiv.className = 'formatting-change';
                changeDiv.textContent = 'HTML structure or table formatting has changed';
                formattingList.appendChild(changeDiv);
            } else {
                formattingList.innerHTML = '<div style="color: #28a745; text-align: center;">No formatting changes detected</div>';
            }
            
            // Show no differences message if texts are identical
            if (totalChanges === 0) {
                resultsDiv.innerHTML = `
                    <h2>Comparison Results</h2>
                    <div class="no-differences">
                        âœ… No differences found! The texts are identical.
                    </div>
                `;
            }
        }

        // Enable paste with formatting
        document.getElementById('text1').addEventListener('paste', function(e) {
            // Allow default paste behavior to preserve formatting
        });

        document.getElementById('text2').addEventListener('paste', function(e) {
            // Allow default paste behavior to preserve formatting
        });
    </script>
</body>
</html>
